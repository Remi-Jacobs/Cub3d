// raycasting functions
// SO CLOSE for the 4 walls
// void draw_line(t_player *player, t_game *game, float start_x, int i)
// {
//     float cos_angle = cos(start_x);
//     float sin_angle = sin(start_x);
//     float ray_x = player->playerX;
//     float ray_y = player->playerY;

//     int texture_direction = 0;  // 0 = east, 1 = west, 2 = north, 3 = south
//     int hit_vertical = 0;       // 1 = vertical hit, 0 = horizontal hit

//     // Raycasting loop to find wall hit
//     while (!touch(ray_x, ray_y, game))
//     {
//         ray_x += cos_angle;
//         ray_y += sin_angle;
//     }

//     // Determine which wall side the ray intersects and adjust texture
//     if (fabs(cos_angle) > fabs(sin_angle))  // Vertical hit (East/West walls)
//     {
//         if (cos_angle > 0)
//             texture_direction = 0;  // East wall
//         else
//             texture_direction = 1;  // West wall
//         hit_vertical = 1;
//     }
//     else  // Horizontal hit (North/South walls)
//     {
//         if (sin_angle > 0)
//             texture_direction = 3;  // South wall
//         else
//             texture_direction = 2;  // North wall
//         hit_vertical = 0;
//     }

//     if (!DEBUG)
//     {
//         // Calculate distance to the wall and adjust the height of the wall slice
//         float dist = fixed_dist(player->playerX, player->playerY, ray_x, ray_y, game);
//         float height = (BLOCK / dist) * (WIDTH / 2);
//         int start_y = (HEIGHT - height) / 2;
//         int end = start_y + height;

//         // Draw ceiling
//         for (int y = 0; y < start_y; y++)
//             put_pixel(i, y, game->element->ceiling_color->converted_color, game);

//         // Draw wall with texture based on the direction of the wall
//         while (start_y < end)
//         {
//             // Calculate texture Y coordinate for the wall slice
//             int tex_y = (start_y - (HEIGHT - height) / 2) * game->element->texture->height / height;

//             int tex_x = 0;
//             if (hit_vertical)
//                 tex_x = (int)(ray_y) % BLOCK;  // Horizontal texture for East/West walls
//             else
//                 tex_x = (int)(ray_x) % BLOCK;  // Vertical texture for North/South walls

//             // Fetch texture color for the given coordinates
//             int tex_color = 0;
//             if (texture_direction == 0)  // East texture
//             {
//                 tex_color = get_texture_pixel(game->element->texture->east_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             }
//             else if (texture_direction == 1)  // West texture
//             {
//                 tex_color = get_texture_pixel(game->element->texture->west_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             }
//             else if (texture_direction == 2)  // North texture
//             {
//                 // printf("North texture being applied\n"); // Debugging
//                 tex_color = get_texture_pixel(game->element->texture->north_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             }
//             else if (texture_direction == 3)  // South texture
//             {
//                 // printf("South texture being applied\n"); // Debugging
//                 tex_color = get_texture_pixel(game->element->texture->south_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             }

//             put_pixel(i, start_y, tex_color, game);
//             start_y++;
//         }

//         // Draw floor
//         for (int y = end; y < HEIGHT; y++)
//             put_pixel(i, y, game->element->floor_color->converted_color, game);
//     }
// }


// This does just east and west walls but well
// void draw_line(t_player *player, t_game *game, float start_x, int i)
// {
//     float cos_angle = cos(start_x);
//     float sin_angle = sin(start_x);
//     float ray_x = player->playerX;
//     float ray_y = player->playerY;

//     int texture_direction = 0; // 0 = east, 1 = west, 2 = north, 3 = south
//     int hit_vertical = 0; // 1 = vertical hit, 0 = horizontal hit

//     // Raycasting loop to find wall hit
//     while (!touch(ray_x, ray_y, game))
//     {
//         ray_x += cos_angle;
//         ray_y += sin_angle;
//     }

//     // Determine which wall side the ray intersects and adjust texture
//     if (cos_angle > 0) 
//     {
//         texture_direction = 0;  // Ray hits east wall
//         hit_vertical = 1;  // Vertical hit for East/West
//     }
//     else if (cos_angle < 0) 
//     {
//         texture_direction = 1;  // Ray hits west wall
//         hit_vertical = 1;  // Vertical hit for East/West
//     }
//     else if (sin_angle > 0) 
//     {
//         texture_direction = 3;  // Ray hits south wall
//         hit_vertical = 0;  // Horizontal hit for North/South
//     }
//     else if (sin_angle < 0) 
//     {
//         texture_direction = 2;  // Ray hits north wall
//         hit_vertical = 0;  // Horizontal hit for North/South
//     }

//     if (!DEBUG)
//     {
//         // Calculate distance to the wall and adjust the height of the wall slice
//         float dist = fixed_dist(player->playerX, player->playerY, ray_x, ray_y, game);
//         float height = (BLOCK / dist) * (WIDTH / 2);
//         int start_y = (HEIGHT - height) / 2;
//         int end = start_y + height;

//         // Draw ceiling
//         for (int y = 0; y < start_y; y++)
//             put_pixel(i, y, game->element->ceiling_color->converted_color, game);

//         // Draw wall with texture based on the direction of the wall
//         while (start_y < end)
//         {
//             // Calculate texture Y coordinate for the wall slice
//             int tex_y = (start_y - (HEIGHT - height) / 2) * game->element->texture->height / height;

//             int tex_x = 0;
//             if (hit_vertical) 
//                 tex_x = (int)(ray_y) % BLOCK; // Horizontal texture for East/West walls
//             else 
//                 tex_x = (int)(ray_x) % BLOCK; // Vertical texture for North/South walls

//             // Fetch texture color for the given coordinates
//             int tex_color = 0;
//             if (texture_direction == 0)  // East texture
//                 tex_color = get_texture_pixel(game->element->texture->east_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             else if (texture_direction == 1)  // West texture
//                 tex_color = get_texture_pixel(game->element->texture->west_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             else if (texture_direction == 2)  // North texture
//                 tex_color = get_texture_pixel(game->element->texture->north_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//             else if (texture_direction == 3)  // South texture
//                 tex_color = get_texture_pixel(game->element->texture->south_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);

//             put_pixel(i, start_y, tex_color, game);
//             start_y++;
//         }

//         // Draw floor
//         for (int y = end; y < HEIGHT; y++)
//             put_pixel(i, y, game->element->floor_color->converted_color, game);
//     }
// }


/ void draw_line(t_player *player, t_game *game, float start_x, int i)
// {
//     float cos_angle = cos(start_x);
//     float sin_angle = sin(start_x);
//     float ray_x = player->playerX;
//     float ray_y = player->playerY;

//     while(!touch(ray_x, ray_y, game))
//     {
//         if(DEBUG)
//             put_pixel(ray_x, ray_y, 0xFF0000, game);
//         ray_x += cos_angle;
//         ray_y += sin_angle;
//     }
//     if(!DEBUG)
//     {
//         float dist = fixed_dist(player->playerX, player->playerY, ray_x, ray_y, game);
//         float height = (BLOCK / dist) * (WIDTH / 2);
//         int start_y = (HEIGHT - height) / 2;
//         int end = start_y + height;
// 		for (int y = 0; y < start_y; y++)
//         	put_pixel(i, y, game->element->ceiling_color->converted_color, game); 

//         //this drawas the wall
//         while(start_y < end)
//         {
//             put_pixel(i, start_y, 0xFFF00, game);
//             start_y++;
//         }

//         //this draws the floor
// 		for (int y = end; y < HEIGHT; y++)
//         	put_pixel(i, y, game->element->floor_color->converted_color, game); // i used this to draw the floor
//     }
// }


// int main(int ac, char **argv)
// {
//     t_game game;
//     // init

//     // Assuming valid_extension_args_no and parsing_func are defined elsewhere
//     // if (!valid_extension_file_check(argv[1], ac, "cub"))
//     //     return (0);
    // init_game(&game, argv[1]);
    
	
//     // hooks
//     mlx_hook(game.win, 2, 1L<<0, key_press, &game.player);
//     mlx_hook(game.win, 3, 1L<<1, key_release, &game.player);
//     // draw loop
    // mlx_loop_hook(game.mlx, draw_loop, &game);

//     mlx_loop(game.mlx);
//     return 0;
// }


// # include "../includes/game.h"

// int	set_player_angle(t_map *map, t_player *player)
// {
// 	if (map->map[map->player_column][map->player_row] == 'N')
// 		player->angle = 3 * PI / 2;
// 	else if (map->map[map->player_column][map->player_row] == 'S')
// 		player->angle = PI / 2;
// 	else if (map->map[map->player_column][map->player_row] == 'E')
// 		player->angle = 0;
// 	else if (map->map[map->player_column][map->player_row] == 'W')
// 		player->angle =  PI;
// 	else
// 	{
// 		ft_error("EROOR : Need a position to start\n");
// 		return (0);
// 	}
// 	return (1);
// }

// int	init_player(t_player *player, t_map *map)
// {
// 	player->playerX = map->player_row * BLOCK + BLOCK / 2;
// 	player->playerY = map->player_column * BLOCK + BLOCK / 2;
// 	if (!set_player_angle(map, player))
// 		return (0);
// 	player->key_up = false;
// 	player->key_down = false;
// 	player->key_right = false;
// 	player->key_left = false;
// 	player->left_rotate = false;
// 	player->right_rotate = false;
// 	return (1);
// }

// int	key_press(int keycode, t_player *player)
// {
// 	if(keycode == W)
// 		player->key_up = true;
// 	if(keycode == S)
// 		player->key_down = true;
// 	if(keycode == A)
// 		player->key_left = true;
// 	if(keycode == D)
// 		player->key_right = true;
// 	if(keycode == LEFT)
// 		player->left_rotate = true;
// 	if(keycode == RIGHT)
// 		player->right_rotate = true;
// 	return (0);
// }

// int key_release(int keycode, t_player *player)
// {
//     if(keycode == W)
//         player->key_up = false;
//     if(keycode == S)
//         player->key_down = false;
//     if(keycode == A)
//         player->key_left = false;
//     if(keycode == D)
//         player->key_right = false;
//     if(keycode == LEFT)
//         player->left_rotate = false;
//     if(keycode == RIGHT)
//         player->right_rotate = false;
//     return 0;
// }

// void move_player(t_player *player, t_game *game)
// {
//     int speed = 3;
//     float angle_speed = 0.03;
//     float cos_angle = cos(player->angle);
//     float sin_angle = sin(player->angle);

//     if (player->left_rotate)
//         player->angle -= angle_speed;
//     if (player->right_rotate)
//         player->angle += angle_speed;
//     if (player->angle > 2 * PI)
//         player->angle -= 2 * PI;
//     if (player->angle < 0)
//         player->angle += 2 * PI;

//     // Check collision before moving forward
//     if (player->key_up)
//     {
//         float new_x = player->playerX + cos_angle * speed;
//         float new_y = player->playerY + sin_angle * speed;
//         if (!touch(new_x, player->playerY, game)) // Check X movement
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game)) // Check Y movement
//             player->playerY = new_y;
//     }

//     // Check collision before moving backward
//     if (player->key_down)
//     {
//         float new_x = player->playerX - cos_angle * speed;
//         float new_y = player->playerY - sin_angle * speed;
//         if (!touch(new_x, player->playerY, game)) // Check X movement
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game)) // Check Y movement
//             player->playerY = new_y;
//     }

//     // Check collision before strafing left
//     if (player->key_left)
//     {
//         float new_x = player->playerX + sin_angle * speed;
//         float new_y = player->playerY - cos_angle * speed;
//         if (!touch(new_x, player->playerY, game)) // Check X movement
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game)) // Check Y movement
//             player->playerY = new_y;
//     }

//     // Check collision before strafing right
//     if (player->key_right)
//     {
//         float new_x = player->playerX - sin_angle * speed;
//         float new_y = player->playerY + cos_angle * speed;
//         if (!touch(new_x, player->playerY, game)) // Check X movement
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game)) // Check Y movement
//             player->playerY = new_y;
//     }
// }


// // void move_player(t_player *player)
// // {
// //     int speed = 3;
// //     float angle_speed = 0.03;
// //     float cos_angle = cos(player->angle);
// //     float sin_angle = sin(player->angle);

// //     if (player->left_rotate)
// //         player->angle -= angle_speed;
// //     if (player->right_rotate)
// //         player->angle += angle_speed;
// //     if (player->angle > 2 * PI)
// //         player->angle = 0;
// //     if (player->angle < 0)
// //         player->angle = 2 * PI;
	
// // 	if (player->key_up)
// //     {
// //         player->playerX += cos_angle * speed;
// //         player->playerY += sin_angle * speed;
// //     }
// //     if (player->key_down)
// //     {
// //         player->playerX -= cos_angle * speed;
// //         player->playerY -= sin_angle * speed;
// //     }
// //     if (player->key_left)
// //     {
// //         player->playerX += sin_angle * speed;
// //         player->playerY -= cos_angle * speed;
// //     }
// //     if (player->key_right)
// //     {
// //         player->playerX -= sin_angle * speed;
// //         player->playerY += cos_angle * speed;
// //     }
// // }


/ void draw_line(t_player *player, t_game *game, float start_x, int i)
// {
//     float cos_angle = cos(start_x);
//     float sin_angle = sin(start_x);

//     float ray_x = player->playerX;
//     float ray_y = player->playerY;

//     int texture_direction = 0; // 0 = east, 1 = west, 2 = north, 3 = south
//     int hit_vertical = 0;      // 1 = vertical hit, 0 = horizontal hit

//     // Initialize raycasting distances
//     float delta_dist_x = fabs(1 / cos_angle); // Distance to next vertical gridline
//     float delta_dist_y = fabs(1 / sin_angle); // Distance to next horizontal gridline

//     float step_x = (cos_angle > 0) ? 1 : -1; // Step direction for X
//     float step_y = (sin_angle > 0) ? 1 : -1; // Step direction for Y

//     float side_dist_x = (cos_angle > 0) ? 
//         (floor(ray_x / BLOCK) * BLOCK + BLOCK - ray_x) * delta_dist_x :
//         (ray_x - floor(ray_x / BLOCK) * BLOCK) * delta_dist_x;

//     float side_dist_y = (sin_angle > 0) ? 
//         (floor(ray_y / BLOCK) * BLOCK + BLOCK - ray_y) * delta_dist_y :
//         (ray_y - floor(ray_y / BLOCK) * BLOCK) * delta_dist_y;

//     // Raycasting loop to find wall hit
//     while (!touch(ray_x, ray_y, game))
//     {
//         if (side_dist_x < side_dist_y) // Vertical hit (East/West wall)
//         {
//             side_dist_x += delta_dist_x;
//             ray_x += step_x;
//             ray_y += step_x * sin_angle / cos_angle;
//             hit_vertical = 1;
//             texture_direction = (cos_angle > 0) ? 0 : 1; // East or West
//         }
//         else // Horizontal hit (North/South wall)
//         {
//             side_dist_y += delta_dist_y;
//             ray_y += step_y;
//             ray_x += step_y * cos_angle / sin_angle;
//             hit_vertical = 0;
//             texture_direction = (sin_angle > 0) ? 3 : 2; // South or North
//         }
//     }

//     // Calculate perpendicular distance to the wall
//     float dist = fixed_dist(player->playerX, player->playerY, ray_x, ray_y, game);

//     // Calculate wall height
//     float height = (BLOCK / dist) * (WIDTH / 2);
//     int start_y = (HEIGHT - height) / 2;
//     int end = start_y + height;

//     // Clamp wall slice rendering bounds
//     if (start_y < 0) start_y = 0;
//     if (end >= HEIGHT) end = HEIGHT - 1;

//     // Draw ceiling
//     for (int y = 0; y < start_y; y++)
//         put_pixel(i, y, game->element->ceiling_color->converted_color, game);

//     // Draw the wall with texture
//     while (start_y < end)
//     {
//         // Calculate texture Y coordinate for the wall slice
//         int tex_y = (start_y - (HEIGHT - height) / 2) * game->element->texture->height / height;

//         // Clamp texture Y coordinate
//         if (tex_y < 0) tex_y = 0;
//         if (tex_y >= game->element->texture->height) tex_y = game->element->texture->height - 1;

//         // Calculate texture X coordinate
//         int tex_x = (hit_vertical ? ((int)ray_y % BLOCK) : ((int)ray_x % BLOCK));
//         tex_x = (tex_x * game->element->texture->width) / BLOCK;

//         // Clamp texture X coordinate
//         if (tex_x < 0) tex_x = 0;
//         if (tex_x >= game->element->texture->width) tex_x = game->element->texture->width - 1;

//         // Fetch texture color
//         int tex_color = 0;
//         if (texture_direction == 0)  // East texture
//             tex_color = get_texture_pixel(game->element->texture->east_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 1)  // West texture
//             tex_color = get_texture_pixel(game->element->texture->west_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 2)  // North texture
//             tex_color = get_texture_pixel(game->element->texture->north_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 3)  // South texture
//             tex_color = get_texture_pixel(game->element->texture->south_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);

//         put_pixel(i, start_y, tex_color, game);
//         start_y++;
//     }

//     // Draw floor
//     for (int y = end; y < HEIGHT; y++)
//         put_pixel(i, y, game->element->floor_color->converted_color, game);
// }

// void draw_line(t_player *player, t_game *game, float start_x, int i)
// {
//     float cos_angle = cos(start_x);
//     float sin_angle = sin(start_x);

//     float ray_x = player->playerX;
//     float ray_y = player->playerY;

//     int texture_direction = 0; // 0 = east, 1 = west, 2 = north, 3 = south
//     int hit_vertical = 0;      // 1 = vertical hit, 0 = horizontal hit

//     float delta_dist_x = fabs(1 / cos_angle);
//     float delta_dist_y = fabs(1 / sin_angle);

//     float step_x = (cos_angle > 0) ? 1 : -1;
//     float step_y = (sin_angle > 0) ? 1 : -1;

//     float side_dist_x = (cos_angle > 0) ? 
//         (floor(ray_x / BLOCK) * BLOCK + BLOCK - ray_x) * delta_dist_x :
//         (ray_x - floor(ray_x / BLOCK) * BLOCK) * delta_dist_x;

//     float side_dist_y = (sin_angle > 0) ? 
//         (floor(ray_y / BLOCK) * BLOCK + BLOCK - ray_y) * delta_dist_y :
//         (ray_y - floor(ray_y / BLOCK) * BLOCK) * delta_dist_y;

//     while (!touch(ray_x, ray_y, game))
//     {
//         if (side_dist_x < side_dist_y)
//         {
//             side_dist_x += delta_dist_x;
//             ray_x += step_x;
//             ray_y += step_x * sin_angle / cos_angle;
//             hit_vertical = 1;
//             texture_direction = (cos_angle > 0) ? 0 : 1;
//         }
//         else
//         {
//             side_dist_y += delta_dist_y;
//             ray_y += step_y;
//             ray_x += step_y * cos_angle / sin_angle;
//             hit_vertical = 0;
//             texture_direction = (sin_angle > 0) ? 3 : 2;
//         }
//     }

//     float dist = fixed_dist(player->playerX, player->playerY, ray_x, ray_y, game);
//     float height = (BLOCK / dist) * (WIDTH / 2);
//     int start_y = (HEIGHT - height) / 2;
//     int end = start_y + height;

//     if (start_y < 0) start_y = 0;
//     if (end >= HEIGHT) end = HEIGHT - 1;

//     for (int y = 0; y < start_y; y++)
//         put_pixel(i, y, game->element->ceiling_color->converted_color, game);

//     while (start_y < end)
//     {
//         int tex_y = (start_y - (HEIGHT - height) / 2) * game->element->texture->height / height;
//         tex_y = tex_y < 0 ? 0 : tex_y;
//         tex_y = tex_y >= game->element->texture->height ? game->element->texture->height - 1 : tex_y;

//         int tex_x = hit_vertical ? ((int)ray_y % BLOCK) : ((int)ray_x % BLOCK);
//         tex_x = (tex_x * game->element->texture->width) / BLOCK;
//         tex_x = tex_x < 0 ? 0 : tex_x;
//         tex_x = tex_x >= game->element->texture->width ? game->element->texture->width - 1 : tex_x;

//         int tex_color = 0;
//         if (texture_direction == 0)
//             tex_color = get_texture_pixel(game->element->texture->east_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 1)
//             tex_color = get_texture_pixel(game->element->texture->west_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 2)
//             tex_color = get_texture_pixel(game->element->texture->north_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);
//         else if (texture_direction == 3)
//             tex_color = get_texture_pixel(game->element->texture->south_data, tex_x, tex_y, game->element->texture->size_line, game->element->texture->bpp);

//         put_pixel(i, start_y, tex_color, game);
//         start_y++;
//     }

//     for (int y = end; y < HEIGHT; y++)
//         put_pixel(i, y, game->element->floor_color->converted_color, game);
// }


// void move_player(t_player *player, t_game *game)
// {
//     int speed = 3;
//     float angle_speed = 0.03;
//     float cos_angle = cos(player->angle);
//     float sin_angle = sin(player->angle);

//     if (player->left_rotate)
//         player->angle -= angle_speed;
//     if (player->right_rotate)
//         player->angle += angle_speed;
//     if (player->angle > 2 * PI)
//         player->angle -= 2 * PI;
//     if (player->angle < 0)
//         player->angle += 2 * PI;

//     // Check collision before moving forward
//     if (player->key_up)
//     {
//         float new_x = player->playerX + cos_angle * speed;
//         float new_y = player->playerY + sin_angle * speed;
//         if (!touch(new_x, player->playerY, game))
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game))
//             player->playerY = new_y;
//     }

//     // Check collision before moving backward
//     if (player->key_down)
//     {
//         float new_x = player->playerX - cos_angle * speed;
//         float new_y = player->playerY - sin_angle * speed;
//         if (!touch(new_x, player->playerY, game))
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game))
//             player->playerY = new_y;
//     }

//     // Check collision before strafing left
//     if (player->key_left)
//     {
//         float new_x = player->playerX + sin_angle * speed;
//         float new_y = player->playerY - cos_angle * speed;
//         if (!touch(new_x, player->playerY, game))
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game))
//             player->playerY = new_y;
//     }

//     // Check collision before strafing right
//     if (player->key_right)
//     {
//         float new_x = player->playerX - sin_angle * speed;
//         float new_y = player->playerY + cos_angle * speed;
//         if (!touch(new_x, player->playerY, game))
//             player->playerX = new_x;
//         if (!touch(player->playerX, new_y, game))
//             player->playerY = new_y;
//     }
// }